package server

import (
	"context"
	"fmt"
	"log"
	"net"
	"time"

	"google.golang.org/grpc"

	"github.com/yourusername/browser_render_go/src/browser"
	"github.com/yourusername/browser_render_go/src/config"
	"github.com/yourusername/browser_render_go/src/storage"

	// Note: This import path will be generated by protoc
	// pb "github.com/yourusername/browser_render_go/gen/proto/browser_render/v1"
)

// Temporary struct definitions until protoc generates them
type GetVehicleDataRequest struct {
	BranchId   string
	FilterId   string
	ForceLogin bool
}

type GetVehicleDataResponse struct {
	Status     string
	StatusCode int32
	Data       []*VehicleData
	SessionId  string
}

type VehicleData struct {
	VehicleCd   string
	VehicleName string
	Status      string
	Metadata    map[string]string
}

type CheckSessionRequest struct {
	SessionId string
}

type CheckSessionResponse struct {
	IsValid bool
	Message string
}

type ClearSessionRequest struct {
	SessionId string
}

type ClearSessionResponse struct {
	Success bool
	Message string
}

type HealthCheckRequest struct{}

type HealthCheckResponse struct {
	Status  string
	Version string
	Uptime  int64
}

// GRPCServer implements the BrowserRenderService
type GRPCServer struct {
	// pb.UnimplementedBrowserRenderServiceServer
	config    *config.Config
	storage   *storage.Storage
	renderer  *browser.Renderer
	startTime time.Time
}

// NewGRPCServer creates a new gRPC server instance
func NewGRPCServer(cfg *config.Config, store *storage.Storage, renderer *browser.Renderer) *GRPCServer {
	return &GRPCServer{
		config:    cfg,
		storage:   store,
		renderer:  renderer,
		startTime: time.Now(),
	}
}

// GetVehicleData retrieves vehicle data from the website
func (s *GRPCServer) GetVehicleData(ctx context.Context, req *GetVehicleDataRequest) (*GetVehicleDataResponse, error) {
	log.Printf("GetVehicleData called with branchId=%s, filterId=%s", req.BranchId, req.FilterId)

	// Get vehicle data using the browser renderer
	vehicleData, sessionID, err := s.renderer.GetVehicleData(
		ctx,
		"", // Session ID from request if needed
		req.BranchId,
		req.FilterId,
		req.ForceLogin,
	)
	if err != nil {
		log.Printf("Error getting vehicle data: %v", err)
		return &GetVehicleDataResponse{
			Status:     err.Error(),
			StatusCode: 500,
			Data:       []*VehicleData{},
		}, nil
	}

	// Convert to protobuf format
	pbVehicleData := make([]*VehicleData, len(vehicleData))
	for i, v := range vehicleData {
		pbVehicleData[i] = &VehicleData{
			VehicleCd:   v.VehicleCD,
			VehicleName: v.VehicleName,
			Status:      v.Status,
			Metadata:    v.Metadata,
		}
	}

	return &GetVehicleDataResponse{
		Status:     "success",
		StatusCode: 200,
		Data:       pbVehicleData,
		SessionId:  sessionID,
	}, nil
}

// CheckSession validates if a session is still active
func (s *GRPCServer) CheckSession(ctx context.Context, req *CheckSessionRequest) (*CheckSessionResponse, error) {
	log.Printf("CheckSession called with sessionId=%s", req.SessionId)

	if req.SessionId == "" {
		return &CheckSessionResponse{
			IsValid: false,
			Message: "Session ID is required",
		}, nil
	}

	isValid, message := s.renderer.CheckSession(req.SessionId)
	return &CheckSessionResponse{
		IsValid: isValid,
		Message: message,
	}, nil
}

// ClearSession removes a session and its associated data
func (s *GRPCServer) ClearSession(ctx context.Context, req *ClearSessionRequest) (*ClearSessionResponse, error) {
	log.Printf("ClearSession called with sessionId=%s", req.SessionId)

	if req.SessionId == "" {
		return &ClearSessionResponse{
			Success: false,
			Message: "Session ID is required",
		}, nil
	}

	err := s.renderer.ClearSession(req.SessionId)
	if err != nil {
		return &ClearSessionResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to clear session: %v", err),
		}, nil
	}

	return &ClearSessionResponse{
		Success: true,
		Message: "Session cleared successfully",
	}, nil
}

// HealthCheck returns the service health status
func (s *GRPCServer) HealthCheck(ctx context.Context, req *HealthCheckRequest) (*HealthCheckResponse, error) {
	uptime := int64(time.Since(s.startTime).Seconds())
	return &HealthCheckResponse{
		Status:  "healthy",
		Version: "1.0.0",
		Uptime:  uptime,
	}, nil
}

// Start starts the gRPC server
func (s *GRPCServer) Start(address string) error {
	lis, err := net.Listen("tcp", address)
	if err != nil {
		return fmt.Errorf("failed to listen: %w", err)
	}

	// Create gRPC server with options
	grpcServer := grpc.NewServer(
		grpc.MaxRecvMsgSize(10*1024*1024), // 10MB
		grpc.MaxSendMsgSize(10*1024*1024), // 10MB
		grpc.MaxConcurrentStreams(100),
	)

	// Register service
	// pb.RegisterBrowserRenderServiceServer(grpcServer, s)

	log.Printf("gRPC server starting on %s", address)
	if err := grpcServer.Serve(lis); err != nil {
		return fmt.Errorf("failed to serve: %w", err)
	}

	return nil
}